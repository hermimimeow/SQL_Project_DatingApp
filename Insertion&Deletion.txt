MILESTONE2
ZHIYAN DENG

---USER TABLE
When there is a new user register the App, the “users” table will start to collect their basic information. 

The rule we used to generate user_id is using: 'GENERATED ALWAYS AS IDENTITY PRIMARY KEY'
CREATE TABLE users(
 	user_id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
 	phone_number bigint NOT NULL,
 	gender character(1) NOT NULL,
	race VARCHAR(12) NOT NULL,
	verification boolean,
	zipcode character(5) NOT NULL,
	income_level integer NOT NULL,
	profile_word_count smallint NOT NULL,
	profile_photo_count smallint NOT NULL,
	birthdate date NOT NULL
)

The user_id column will be automatically generated by the system with a unique number assigned to each user. So we do not have to insert any values to the "user_id" column manually. At the same time, this column is also serves as the PRIMARY KEY of the users table. 
INSERT INTO project.users(phone_number,gender,race,verification,zipcode ,income_level, profile_word_count, profile_photo_count, birthdate)
VALUES
	('6172517699','m','Asian', False,'02139', 100000,550,15,'1975-10-29');

“phone_number”: One phone number can be only registered by one user. So, we also applied a unique constraint on this column to make sure of that. If a user put in a phone number has already been used for registration, he/she won’t be able to go continue to the next registration page.

UNIQUE CONSTRAINT on phone_number: 
ALTER TABLE project.users ADD CONSTRAINT uq_phone_number UNIQUE (phone_number)

“birthdate”: We have an age restriction, so we put a check constraint on users whose birth date is equal or after 2002-01-01. If a user put down their birth date that is before the year 2002, he/she won’t be able to finish the registration of the App.      

CHECK CONSTRAINT on birthdate:
ALTER TABLE project.users ADD CONSTRAINT ck_user_birthdate CHECK (birthdate  <= '2002-01-01'::date)

The command to retrieve all the inserted data: SELECT * FROM project.users 

If a registered user made some changes on the profile. Like user_id:12345678 upload the photo ID to the system, we will need to update the record with command in his/her profile:

UPDATE project.users
SET verification = TRUE
WHERE user_id = 12345678


---PACKAGE TABLE
CREATE TABLE package(
	membership_package VARCHAR(255) PRIMARY KEY,
	likes_sent bigint NOT NULL,
	likes_received bigint NOT NULL);

The “package” table is a reference table to the “membership” table. There are two types of membership packages a user can choose after they finish the account registration. One is “Vip” package that allows a user to send and receive up to 50 likes within a year. “Supervip” package will up to 100 likes of quota in send and receive.  Here’s the command to insert how many likes each different packages we are offering to users.


INSERT INTO package (membership_package,likes_received,likes_sent)
VALUES ('Supervip',100,100);
INSERT INTO package (membership_package,likes_received,likes_sent)
VALUES ('Vip',50,50);


-----MEMBERSHIP TABLE
CREATE TABLE membership(
	package_name VARCHAR(255) PRIMARY KEY,
	user_id bigint NOT NULL,
	period daterange NOT NULL);

A user now can make their decisions. If he/she chose a “Supervip” membership, here’s the command to insert their decision:

INSERT INTO project.membership (user_id, period, package_name)
VALUES (123456789, daterange('2021-5-1', '2022-5-1'), 'Supervip');

The membership_id serves as the PRIMARY KEY of this table, and each membership_id records a user subscribe to which membership package during what time. The rule to generate the membership_id is similar to the user_id in users table. 
'membership_id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY'

There are no limits on how many packages a user can subscribe to at a time, but each package does have a limited time duration, which is one year. 

If the same user used up all the likes, he/she can choose to subscribe to an extra package, and we can insert the record:

Similar to the users table, the membership_id column here we are also using the auto generation rule. 'GENERATED ALWAYS AS IDENTITY PRIMARY KEY'. 
The system will auto assign each membership subscription with a unique identity number. Therefore, we don't have to manually insert any values. 

INSERT INTO project.membership(user_id, period, package_name)
VALUES (1, daterange('2022-4-28','2023-4-28'),'Vip');

FOREIGN KEYS with “membership” and “users” table:
ALTER TABLE project.membership ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES project.users (user_id)
ON UPDATE CASCADE
ON DELETE CASCADE
;
If a user is deleting the account, the “user” table will use following command to stop collecting records from this user: 
DELETE FROM project.users WHERE user_id = 123456789

A FOREIGN KEY with an UPDATE/DELETE CASCADE in between two tables, the user_id and its related information will also be all deleted from the “membership” table.


Another FOREIGN KEYS with “membership” table and “package” table, where the “package” table is the reference table that shows how many likes limit from each membership.

ALTER TABLE membership ADD CONSTRAINT fk_package_name FOREIGN KEY (package_name) REFERENCES package (membership_package)
ON UPDATE CASCADE
ON DELETE CASCADE
;

Before user filling a new record to the “match” table, we need to run a query and check how many likes this user have sent out already, and if the number has gone beyond the limit of their current subscription: 

SELECT * FROM project.match
WHERE sender_id = 123456789 

Similar thing, if the receiver have receive maximum amounts of likes, his/her account will no longer receive likes from other users. 

SELECT * FROM project.match
WHERE receiver_id = 1


-----MATCH TABLE
CREATE TABLE membership(
	package_name VARCHAR(255) PRIMARY KEY,
	user_id bigint NOT NULL,
	period daterange NOT NULL);
When user to send out likes, their actions will be recorded in the “match” table.
A user will be given a sender_id and a match_id if he/she sent out likes to other users. It records the liking action of a user. If there is no response to the likes that senders sent, the receiver_id column will remain NULL, as well as the response_date. Command as following:

Since match_id column also uses 'GENERATED ALWAYS AS IDENTITY PRIMARY KEY'. So when the record started, we don't have to manually insert any match_id number for the matching interaction. 

Our App is only targeting users in the United States. Therefore, the timezone we are using to record is the Pacific Time (INCLUDING BOTH PST and PDT). 
INSERT INTO project. match(sender_id,receiver_id,send_date,response_date,delete_chat)
VALUES
	(123456789, NULL,'2022-03-03 21:30:00-05' AT TIME ZONE 'Pacific Time',NULL,FALSE);

If there is response from the receiver, there will be an update in the receiver_id and response_date columns:


If the CONVERSATION TABLE is closed, the "delete_chat" column with Boolean will change from FALSE to TRUE. That will requires our manual update for them.


UPDATE project.match
SET receiver_id = 12345678, response_date = '2022-03-03 22:30:00-05' AT TIME ZONE 'PT'
WHERE match_id = 10020;	

The PRIMARY KEY of the “match” table is the match_id. It records different likes sending activity of a user. 

ALTER TABLE project.match ADD CONSTRAINT pk_match_id PRIMARY KEY (match_id)

Two FOREIGN CONSTRAINTS with the “users” table, with the UPDATE/DELETE CASCADE, it ensures that if a user is deleted from “users” table, all the related records of this user will be delete from the “match” table as well. 
ALTER TABLE project.match ADD CONSTRAINT fk_user1_id FOREIGN KEY (sender_id) REFERENCES project.users (user_id)
ON UPDATE CASCADE
ON DELETE CASCADE
;
ALTER TABLE project.match ADD CONSTRAINT fk_user2_id FOREIGN KEY (receiver_id) REFERENCES project.users (user_id)
ON UPDATE CASCADE
ON DELETE CASCADE
;

If probably shows lots of “NULL” s in the table but consider that as normal since not every single like will receive a response. 

-----CONVERSATION TABLE
In-App text conversation.
Before users exchange their numbers with each other, the texting function in our App could better protect users’ privacy from other users. 
An auto-generated conversation_id will assign to every two users who accomplished actions of mutually sending and receive likes from each other.
CREATE TABLE project.in_app_conversation (
 	conversation_id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
 	period daterange NOT NULL,
	match_id bigint NOT NULL
);


This table, it records users’ texting conversations mainly. After both users send and response to the likes, the in_app_conversation will be activated. 


After a certain interaction time, users can choose if they have successfully met in person or if the interaction between two users is just failed. Or they can continue to interact with each other in the App’s chat box. A user can also decide to delete the conversation box if they don’t have the feeling to continue chatting with each other. By doing so, the chat box will close, and records will be closed. The “period” column will record the closing date for a particular conversation. 

ALTER TABLE project.in_app_conversation ADD CONSTRAINT fk_match_id FOREIGN KEY (match_id) REFERENCES project.match (match_id)
ON UPDATE CASCADE
ON DELETE RESTRICT
;


When users want to end the conversation even there aren't any conversation in between the two, they can choose to delete the in_app_conversation box. That would give an update to their conversation period at the end. The conversation_id will be removed once the period column is fulfilled. As to conversation table and match table, in order not to messed up with the match table which also records all the likes of an individual user, we are applying DELETE RESTRICT in this case. 

A "delete_chat" column in the match table will need to be updated and record whether the conversation between two users has ended. 

UPDATE project.match
SET delete_chat = TRUE
WHERE match_id = 12345678



 


INSERT INTO project.in_app_conversation(period, match_id)
VALUES
	(daterange('2022-07-01', CURRENT_DATE,'[]'),2)

UPDATE project.in_app_conversation
SET period = '[2022-07-01, 2022-12-01)'
WHERE conversation_id = 2

If the conversation has ended by a delete command, we will need to update the record in the in_app_conversation table:

DELETE FROM project.in_app_conversation WHERE conversation_id = 2

Since the match_id as a FOREIGN KEY between the match table and the in_app_conversation table has the UPDATE CASCADE DELETE RESTRICT rules, the delete of the conversation_id which happens to be the primary key of the in_app_conversation table will not impact the match_id in the match table. 

The match_id will still be able to serve as record of likes sent, even users have ended their in-app conversation. 


Can see the changes in the in_app_conversation and match table with these codes:
SELECT * FROM project.in_app_conversation

SELECT * FROM project.match







Top three SELECT queries that I need for the database is: 

1) Retrieve records;

SELECT * FROM project.users

Whenever we update the record based on the user’s action, we can use this command to retrieve all our latest record. 

If I want to target groups of the user to analyze and to develop more pay functions for the app
with specified income levels in certain age groups, we can also do the following:

EXAMPLE CODE:
SELECT * FROM project.users
WHERE income_level > 80000 and birthdate < 1980-04-03; 

"WHERE" functions as a filter in here.
"WHERE income_level> 80000" means we only want to look at users who earned more than 80000 per year.
"and" means besides income_level, the outcome also need to satisfy another statement.
"birthdate <1980-04-03" is another statement that we also want to look at users who are born before 1980-04-03.


2) Joins
If we want to see how many successfully match are there (with a receiver response and started a conversation successfully)

SELECT *
FROM match
INNER JOIN conversation
ON match.match_id = conversation.match_id;

 


3) Ranking

To find out the most popular user (most likes received) and offer them benefits, we can use ORDER BY to find them out.

SELECT * FROM project.package ORDER BY likes_received DESC

"ORDER BY likes_received": The command to order the results by "likes_received" column.
"DESC": Descending order.



 
